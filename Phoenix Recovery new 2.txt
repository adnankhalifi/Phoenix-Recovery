//+------------------------------------------------------------------+
//|                                         Phoenix Recovery EA.mq5  |
//|                                      Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ù…ÙˆØ­Ø¯ Ù„Ù„Ø£Ù‡Ø¯Ø§Ù |
//|                                                         V 2.07   |
//+------------------------------------------------------------------+
#property copyright "Phoenix Recovery EA"
#property link      ""
#property version   "2.07"
#property strict

input int GridStepPips = 200;                // Ø§Ù„Ù…Ø³Ø§ÙØ© Ø¨ÙŠÙ† Ø§Ù„Ø®Ø·ÙˆØ· Ø¨Ø§Ù„Ù†Ù‚Ø§Ø·
input int NumberOfLines = 10;                // Ø¹Ø¯Ø¯ Ø§Ù„Ø®Ø·ÙˆØ· ÙÙˆÙ‚/ØªØ­Øª
input double MaxDistanceForNewEntry = 400.0;
input double ReverseDistancePips = 400.0;
input double RiskPerThousand = 0.005;
input int Slippage = 10;
input string CommentPrefix = "PHX_";
input double ProfitPercent = 0.25;
input double RecoveryPercent = 25.0;
input double TotalProfitPercent = 3.0;
input bool RunOneCycle = false;

double globalTotalLoss = 0.0;

struct LineStatus
{
   string lineName;
   double priceLevel;
   int lastPosition;
   ulong ticket;
   double openEquity;
   double targetProfit;
   int tradeCount;
   bool hasOpenedTrade;
   bool isOpening;
   bool isFirstTrade;
};

LineStatus lineStatuses[];
bool isFirstRun = true;
bool linesDrawn = false;
double cycleStartEquity = 0;
double cycleTotalTarget = 0;
bool cycleCompleted = false;

int OnInit()
{
   Print("==============================================");
   Print("ğŸ”¥ Phoenix Recovery EA - V2.07 (Grid System)");
   Print("==============================================");
   Print("Ù†Ø¸Ø§Ù… Grid - Ø§Ù„Ù…Ø³Ø§ÙØ© Ø¨ÙŠÙ† Ø§Ù„Ø®Ø·ÙˆØ·: ", GridStepPips, " Ù†Ù‚Ø·Ø©");
   Print("Ø¹Ø¯Ø¯ Ø§Ù„Ø®Ø·ÙˆØ· ÙÙˆÙ‚/ØªØ­Øª: ", NumberOfLines);
   Print("Ø§Ù„Ù…Ø³Ø§ÙØ© Ø§Ù„Ù‚ØµÙˆÙ‰ Ù„ÙØªØ­ ØµÙÙ‚Ø© Ø¬Ø¯ÙŠØ¯Ø©: ", MaxDistanceForNewEntry, " Ù†Ù‚Ø·Ø©");
   Print("Ø§Ù„Ù…Ø³Ø§ÙØ© Ù„Ø¹ÙƒØ³ Ø§Ù„ØµÙÙ‚Ø©: ", ReverseDistancePips, " Ù†Ù‚Ø·Ø©");
   Print("Ø§Ù„Ù…Ø®Ø§Ø·Ø±Ø©: ", RiskPerThousand, " Ø¯ÙˆÙ„Ø§Ø± Ù„ÙƒÙ„ 1000 Ø¯ÙˆÙ„Ø§Ø± Ù…Ù† Ø§Ù„Ø±ØµÙŠØ¯");
   Print("Ù†Ø³Ø¨Ø© Ø§Ù„Ø±Ø¨Ø­ Ø§Ù„Ø£ÙˆÙ„Ù‰: ", ProfitPercent, "%");
   Print("Ù†Ø³Ø¨Ø© Ø§Ù„Ø§Ø³ØªØ±Ø¯Ø§Ø¯: ", RecoveryPercent, "%");
   Print("Ù†Ø³Ø¨Ø© Ø§Ù„Ø±Ø¨Ø­ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: ", TotalProfitPercent, "%");
   Print("ÙˆØ¶Ø¹ Ø§Ù„Ø¯ÙˆØ±Ø© Ø§Ù„ÙˆØ§Ø­Ø¯Ø©: ", RunOneCycle ? "Ù…ÙØ¹Ù‘Ù„" : "Ù…Ø¹Ø·Ù‘Ù„");
   Print("==============================================");
   
   DeleteOrangeLinesOnly();
   DrawLines();
   InitializeLineStatuses();
   RecalculateAllTargets();
   
   if(cycleStartEquity == 0)
   {
      cycleStartEquity = AccountInfoDouble(ACCOUNT_EQUITY);
      cycleTotalTarget = cycleStartEquity * (1 + TotalProfitPercent / 100.0);
      Print("Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ø¯ÙˆØ±Ø© | Ø§Ù„Ø¥ÙŠÙƒÙˆÙŠØªÙŠ: ", cycleStartEquity, " | Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: ", cycleTotalTarget);
   }
   else
   {
      cycleTotalTarget = cycleStartEquity * (1 + TotalProfitPercent / 100.0);
      Print("ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: ", cycleTotalTarget);
   }
   
   UpdateTargetLabel();
   
   cycleCompleted = false;
   isFirstRun = true;
   linesDrawn = true;
   
   Print("âœ… Phoenix Recovery EA Ø¬Ø§Ù‡Ø² Ù„Ù„Ø¹Ù…Ù„!");
   return(INIT_SUCCEEDED);
}

void OnDeinit(const int reason)
{
   if(reason == REASON_REMOVE || reason == REASON_CHARTCLOSE || reason == REASON_CLOSE)
   {
      Print("Ø­Ø°Ù Ø§Ù„Ø®Ø·ÙˆØ· - Ø§Ù„Ø³Ø¨Ø¨: ", reason);
      DeleteAllLines();
      ObjectDelete(ChartID(), "CHL_TargetLabel");
      ObjectDelete(ChartID(), "CHL_LossLabel");
      ObjectDelete(ChartID(), "CHL_TotalProfitLabel");
      ObjectDelete(ChartID(), "CHL_TargetPerTradeLabel");
      ObjectDelete(ChartID(), "CHL_OpenPositionsLabel");
   }
   else
   {
      Print("Ø§Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ø§Ù„Ø®Ø·ÙˆØ· - Ø§Ù„Ø³Ø¨Ø¨: ", reason, " (ØªØºÙŠÙŠØ± Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª)");
   }
}

void OnTick()
{
   if(cycleCompleted && RunOneCycle)
   {
      return;
   }
   
   UpdateTargetLabel();
   UpdateLossLabel();
   UpdateTotalProfitLabel();
   UpdateTargetPerTradeLabel();
   UpdateOpenPositionsLabel();
   CheckTotalProfitTarget();
   CheckProfitTargets();
   CheckInstantReversal();
   CleanupClosedPositions();
   
   static datetime lastBarTime = 0;
   datetime currentBarTime = iTime(_Symbol, _Period, 0);
   
   if(currentBarTime != lastBarTime)
   {
      // â­ ØªÙ… Ø¥Ø²Ø§Ù„Ø© DrawNewLines() - Ø§Ù„Ø®Ø·ÙˆØ· ØªØ±Ø³Ù… Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø·
      
      if(!isFirstRun)
      {
         CheckLinesCrossing();
      }
      else
      {
         isFirstRun = false;
         Print("Ø§Ù„ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ - Ø§Ù„Ø¥ÙƒØ³Ø¨Ø±Øª Ø¬Ø§Ù‡Ø² Ù„ÙØªØ­ Ø§Ù„ØµÙÙ‚Ø§Øª Ø¹Ù†Ø¯ Ø§Ø®ØªØ±Ø§Ù‚ Ø§Ù„Ø®Ø·ÙˆØ·");
      }
      
      lastBarTime = currentBarTime;
   }
}

void RecalculateAllTargets()
{
   int openPositionsCount = CountOpenPositions();
   
   if(openPositionsCount == 0)
   {
      Print("Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙÙ‚Ø§Øª Ù…ÙØªÙˆØ­Ø© - Ù„Ø§ Ø­Ø§Ø¬Ø© Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù");
      return;
   }
   
   if(globalTotalLoss > 0)
   {
      Print("ğŸ”„ ØªÙ… Ø§ÙƒØªØ´Ø§Ù Ø®Ø³Ø§Ø¦Ø±! Ø³ÙŠØªÙ… ØªØ­ÙˆÙŠÙ„ ÙƒÙ„ Ø§Ù„ØµÙÙ‚Ø§Øª Ù„Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙˆØ²ÙŠØ¹");
      
      for(int i = 0; i < ArraySize(lineStatuses); i++)
      {
         if(lineStatuses[i].ticket > 0 && lineStatuses[i].isFirstTrade)
         {
            Print("ØªØ­ÙˆÙŠÙ„ Ø§Ù„ØµÙÙ‚Ø© ", lineStatuses[i].lineName, " Ù…Ù† ØµÙÙ‚Ø© Ø£ÙˆÙ„Ù‰ Ø¥Ù„Ù‰ Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙˆØ²ÙŠØ¹");
            lineStatuses[i].isFirstTrade = false;
            
            DeleteTargetLabel(lineStatuses[i].lineName);
         }
      }
   }
   
   // â­ Ø­Ø³Ø§Ø¨ Ø§Ù„Ø®Ø³Ø§Ø±Ø© Ø§Ù„ØµØ§ÙÙŠØ©
   double netLoss = globalTotalLoss;
   
   Print("ğŸ“Š globalTotalLoss Ø§Ù„Ø£ØµÙ„ÙŠ: ", globalTotalLoss);
   
   // Ø·Ø±Ø­ Ø§Ù„Ø£Ø±Ø¨Ø§Ø­ Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù„Ù„ØµÙÙ‚Ø§Øª Ø§Ù„Ù…ÙØªÙˆØ­Ø©
   for(int i = 0; i < ArraySize(lineStatuses); i++)
   {
      if(lineStatuses[i].ticket > 0)
      {
         if(PositionSelectByTicket(lineStatuses[i].ticket))
         {
            double currentProfit = PositionGetDouble(POSITION_PROFIT);
            Print("   - Ø§Ù„ØµÙÙ‚Ø© ", lineStatuses[i].lineName, " Ø±Ø¨Ø­Ù‡Ø§ Ø§Ù„Ø­Ø§Ù„ÙŠ: ", currentProfit);
            netLoss -= currentProfit;
         }
      }
   }
   
   if(netLoss < 0) netLoss = 0;
   
   Print("ğŸ“Š Ø§Ù„Ø®Ø³Ø§Ø±Ø© Ø§Ù„ØµØ§ÙÙŠØ© Ø¨Ø¹Ø¯ Ø·Ø±Ø­ Ø§Ù„Ø£Ø±Ø¨Ø§Ø­: ", netLoss);
   
   double totalTarget = 0;
   
   if(netLoss > 0)
   {
      totalTarget = netLoss + (netLoss * RecoveryPercent / 100.0);
      Print("ğŸ“Š Ø¥Ø¹Ø§Ø¯Ø© Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù | Ø§Ù„Ø®Ø³Ø§Ø±Ø© Ø§Ù„ØµØ§ÙÙŠØ©: ", netLoss, " | Ø§Ù„Ù‡Ø¯Ù Ø§Ù„ÙƒÙ„ÙŠ: ", totalTarget);
   }
   else
   {
      Print("ğŸ“Š Ù„Ø§ ØªÙˆØ¬Ø¯ Ø®Ø³Ø§Ø±Ø© ØµØ§ÙÙŠØ© - Ø§Ù„ØµÙÙ‚Ø§Øª Ø³ØªØ³ØªØ®Ø¯Ù… Ø£Ù‡Ø¯Ø§ÙÙ‡Ø§ Ø§Ù„ÙØ±Ø¯ÙŠØ©");
      return;
   }
   
   int distributedPositionsCount = 0;
   for(int i = 0; i < ArraySize(lineStatuses); i++)
   {
      if(lineStatuses[i].ticket > 0)
      {
         distributedPositionsCount++;
      }
   }
   
   if(distributedPositionsCount == 0)
   {
      Print("âš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙÙ‚Ø§Øª Ù…ÙØªÙˆØ­Ø©");
      return;
   }
   
   double targetPerPosition = totalTarget / distributedPositionsCount;
   
   Print("ğŸ¯ Ø§Ù„Ù‡Ø¯Ù Ù„ÙƒÙ„ ØµÙÙ‚Ø©: ", targetPerPosition, " | Ø¹Ø¯Ø¯ Ø§Ù„ØµÙÙ‚Ø§Øª: ", distributedPositionsCount);
   
   for(int i = 0; i < ArraySize(lineStatuses); i++)
   {
      if(lineStatuses[i].ticket > 0)
      {
         lineStatuses[i].targetProfit = targetPerPosition;
         Print("âœ… ØªØ­Ø¯ÙŠØ« Ù‡Ø¯Ù Ø§Ù„Ø®Ø·: ", lineStatuses[i].lineName, " â†’ ", targetPerPosition, "$");
      }
   }
}

void CreateOrUpdateTargetLabel(string lineName, double priceLevel, double targetProfit)
{
   long chartID = ChartID();
   string labelName = "Target_" + lineName;
   string labelText = StringFormat("%.2f$", targetProfit);
   
   if(ObjectFind(chartID, labelName) >= 0)
   {
      ObjectDelete(chartID, labelName);
   }
   
   datetime lineTime = iTime(_Symbol, _Period, 1);
   
   if(ObjectCreate(chartID, labelName, OBJ_TEXT, 0, lineTime, priceLevel))
   {
      ObjectSetString(chartID, labelName, OBJPROP_TEXT, labelText);
      ObjectSetInteger(chartID, labelName, OBJPROP_COLOR, clrOrange);
      ObjectSetInteger(chartID, labelName, OBJPROP_FONTSIZE, 10);
      ObjectSetString(chartID, labelName, OBJPROP_FONT, "Arial Bold");
      ObjectSetInteger(chartID, labelName, OBJPROP_ANCHOR, ANCHOR_LEFT_UPPER);
      ObjectSetInteger(chartID, labelName, OBJPROP_BACK, false);
      ObjectSetInteger(chartID, labelName, OBJPROP_SELECTABLE, false);
      ObjectSetInteger(chartID, labelName, OBJPROP_SELECTED, false);
      ChartRedraw(chartID);
   }
}

void DeleteTargetLabel(string lineName)
{
   long chartID = ChartID();
   string labelName = "Target_" + lineName;
   
   if(ObjectFind(chartID, labelName) >= 0)
   {
      ObjectDelete(chartID, labelName);
   }
}

double PipsToPrice(double pips)
{
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   int digits = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);
   
   double pipFactor = 1.0;
   if(digits == 3 || digits == 5)
      pipFactor = 10.0;
   
   return pips * pipFactor * point;
}

double AddOnePip(double price, bool addUp)
{
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   int digits = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);
   
   double pipFactor = 1.0;
   if(digits == 3 || digits == 5)
      pipFactor = 10.0;
   
   double onePip = point * pipFactor;
   
   if(addUp)
      return price + onePip;
   else
      return price - onePip;
}

double PriceDistanceInPips(double price1, double price2)
{
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   int digits = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);
   
   double pipFactor = 1.0;
   if(digits == 3 || digits == 5)
      pipFactor = 10.0;
   
   return MathAbs(price1 - price2) / (point * pipFactor);
}

string GetTradeRetcodeDescription(uint retcode)
{
   switch(retcode)
   {
      case TRADE_RETCODE_REQUOTE: return "Ø¥Ø¹Ø§Ø¯Ø© ØªØ³Ø¹ÙŠØ±";
      case TRADE_RETCODE_REJECT: return "Ø§Ù„Ø·Ù„Ø¨ Ù…Ø±ÙÙˆØ¶";
      case TRADE_RETCODE_CANCEL: return "ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø·Ù„Ø¨";
      case TRADE_RETCODE_PLACED: return "ØªÙ… ÙˆØ¶Ø¹ Ø§Ù„Ø£Ù…Ø±";
      case TRADE_RETCODE_DONE: return "ØªÙ… Ø§Ù„ØªÙ†ÙÙŠØ°";
      case TRADE_RETCODE_DONE_PARTIAL: return "ØªÙ†ÙÙŠØ° Ø¬Ø²Ø¦ÙŠ";
      case TRADE_RETCODE_ERROR: return "Ø®Ø·Ø£ Ø¹Ø§Ù…";
      case TRADE_RETCODE_TIMEOUT: return "Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„ÙˆÙ‚Øª";
      case TRADE_RETCODE_INVALID: return "Ø·Ù„Ø¨ ØºÙŠØ± ØµØ­ÙŠØ­";
      case TRADE_RETCODE_INVALID_VOLUME: return "Ø­Ø¬Ù… ØºÙŠØ± ØµØ­ÙŠØ­";
      case TRADE_RETCODE_INVALID_PRICE: return "Ø³Ø¹Ø± ØºÙŠØ± ØµØ­ÙŠØ­";
      case TRADE_RETCODE_INVALID_STOPS: return "ÙˆÙ‚Ù Ø®Ø§Ø·Ø¦";
      case TRADE_RETCODE_TRADE_DISABLED: return "Ø§Ù„ØªØ¯Ø§ÙˆÙ„ Ù…Ø¹Ø·Ù„";
      case TRADE_RETCODE_MARKET_CLOSED: return "Ø§Ù„Ø³ÙˆÙ‚ Ù…ØºÙ„Ù‚";
      case TRADE_RETCODE_NO_MONEY: return "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø±ØµÙŠØ¯ ÙƒØ§ÙÙ";
      case TRADE_RETCODE_PRICE_CHANGED: return "ØªØºÙŠØ± Ø§Ù„Ø³Ø¹Ø±";
      case TRADE_RETCODE_PRICE_OFF: return "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ø³Ø¹Ø§Ø±";
      case TRADE_RETCODE_INVALID_EXPIRATION: return "Ø§Ù†ØªÙ‡Ø§Ø¡ ØµÙ„Ø§Ø­ÙŠØ© ØºÙŠØ± ØµØ­ÙŠØ­";
      case TRADE_RETCODE_ORDER_CHANGED: return "ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ø£Ù…Ø±";
      case TRADE_RETCODE_TOO_MANY_REQUESTS: return "Ø¹Ø¯Ø¯ ÙƒØ¨ÙŠØ± Ø¬Ø¯Ø§Ù‹ Ù…Ù† Ø§Ù„Ø·Ù„Ø¨Ø§Øª";
      case TRADE_RETCODE_NO_CHANGES: return "Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØºÙŠÙŠØ±Ø§Øª";
      case TRADE_RETCODE_SERVER_DISABLES_AT: return "Ø§Ù„Ø®Ø§Ø¯Ù… ÙŠØ¹Ø·Ù„ Ø§Ù„ØªØ¯Ø§ÙˆÙ„ Ø§Ù„Ø¢Ù„ÙŠ";
      case TRADE_RETCODE_CLIENT_DISABLES_AT: return "Ø§Ù„Ø¹Ù…ÙŠÙ„ ÙŠØ¹Ø·Ù„ Ø§Ù„ØªØ¯Ø§ÙˆÙ„ Ø§Ù„Ø¢Ù„ÙŠ";
      case TRADE_RETCODE_LOCKED: return "Ù…Ù‚ÙÙ„";
      case TRADE_RETCODE_FROZEN: return "Ù…Ø¬Ù…Ø¯";
      case TRADE_RETCODE_INVALID_FILL: return "ØªØ¹Ø¨Ø¦Ø© ØºÙŠØ± ØµØ­ÙŠØ­Ø©";
      case TRADE_RETCODE_CONNECTION: return "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø§ØªØµØ§Ù„";
      case TRADE_RETCODE_ONLY_REAL: return "Ù…Ø³Ù…ÙˆØ­ ÙÙ‚Ø· Ù„Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ©";
      case TRADE_RETCODE_LIMIT_ORDERS: return "Ø­Ø¯ Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…Ø¹Ù„Ù‚Ø©";
      case TRADE_RETCODE_LIMIT_VOLUME: return "Ø­Ø¯ Ø§Ù„Ø­Ø¬Ù…";
      default: return "Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ: " + IntegerToString(retcode);
   }
}

bool ClosePositionForce(ulong ticket, int maxRetries = 10)
{
   if(ticket == 0) 
   {
      Print("âŒ Ticket = 0, Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„Ø¥ØºÙ„Ø§Ù‚");
      return false;
   }
   
   Print("ğŸ”„ Ø¨Ø¯Ø§ÙŠØ© Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØµÙÙ‚Ø©: ", ticket);
   
   if(!PositionSelectByTicket(ticket))
   {
      Print("âœ… Ø§Ù„ØµÙÙ‚Ø© Ù…Ù‚ÙÙ„Ø© Ù…Ø³Ø¨Ù‚Ø§Ù‹: ", ticket);
      return true;
   }
   
   for(int attempt = 1; attempt <= maxRetries; attempt++)
   {
      Print("ğŸ“Œ Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥ØºÙ„Ø§Ù‚ #", attempt, " Ù…Ù† ", maxRetries);
      
      if(!PositionSelectByTicket(ticket))
      {
         Print("âœ… Ø§Ù„ØµÙÙ‚Ø© Ø£ØºÙ„Ù‚Øª Ø¨Ù†Ø¬Ø§Ø­ ÙÙŠ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© #", attempt);
         return true;
      }
      
      MqlTradeRequest request;
      MqlTradeResult result;
      ZeroMemory(request);
      ZeroMemory(result);
      
      request.action = TRADE_ACTION_DEAL;
      request.position = ticket;
      request.symbol = _Symbol;
      request.volume = PositionGetDouble(POSITION_VOLUME);
      request.deviation = Slippage * 2;
      request.magic = 123456;
      
      if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY)
      {
         request.type = ORDER_TYPE_SELL;
         request.price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      }
      else
      {
         request.type = ORDER_TYPE_BUY;
         request.price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      }
      
      if(OrderSend(request, result))
      {
         if(result.retcode == TRADE_RETCODE_DONE)
         {
            Print("âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø£Ù…Ø± Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ Ø¨Ù†Ø¬Ø§Ø­ - Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© #", attempt);
            Sleep(300);
            
            if(!PositionSelectByTicket(ticket))
            {
               Print("âœ…âœ… ØªØ£ÙƒÙŠØ¯ Ù†Ù‡Ø§Ø¦ÙŠ: Ø§Ù„ØµÙÙ‚Ø© Ù…Ù‚ÙÙ„Ø© ØªÙ…Ø§Ù…Ø§Ù‹!");
               return true;
            }
            else
            {
               Print("âš ï¸ Ø§Ù„ØµÙÙ‚Ø© Ù„Ø§ ØªØ²Ø§Ù„ Ù…ÙˆØ¬ÙˆØ¯Ø© Ø±ØºÙ… Ù†Ø¬Ø§Ø­ Ø§Ù„Ø£Ù…Ø±!");
            }
         }
         else
         {
            Print("âš ï¸ ÙØ´Ù„ Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ - Ø±Ù…Ø² Ø§Ù„Ø®Ø·Ø£: ", result.retcode, " | ", GetTradeRetcodeDescription(result.retcode));
         }
      }
      else
      {
         Print("âŒ ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø£Ù…Ø± Ø§Ù„Ø¥ØºÙ„Ø§Ù‚");
      }
      
      if(attempt < maxRetries)
      {
         int waitTime = attempt * 500;
         Print("â³ Ø§Ù†ØªØ¸Ø§Ø± ", waitTime, " Ù…ÙŠÙ„ÙŠ Ø«Ø§Ù†ÙŠØ© Ù‚Ø¨Ù„ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªØ§Ù„ÙŠØ©...");
         Sleep(waitTime);
      }
   }
   
   Print("âŒâŒâŒ ÙØ´Ù„ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØµÙÙ‚Ø© Ø¨Ø¹Ø¯ ", maxRetries, " Ù…Ø­Ø§ÙˆÙ„Ø©! Ticket: ", ticket);
   
   if(!PositionSelectByTicket(ticket))
   {
      Print("âœ… Ø§Ù„ÙØ­Øµ Ø§Ù„Ø£Ø®ÙŠØ±: Ø§Ù„ØµÙÙ‚Ø© Ù…Ù‚ÙÙ„Ø©!");
      return true;
   }
   
   return false;
}

void CheckInstantReversal()
{
   long chartID = ChartID();
   double currentBid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double currentAsk = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   
   for(int i = 0; i < ArraySize(lineStatuses); i++)
   {
      if(lineStatuses[i].ticket > 0 && lineStatuses[i].hasOpenedTrade)
      {
         if(PositionSelectByTicket(lineStatuses[i].ticket))
         {
            ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            
            double currentPrice = (posType == POSITION_TYPE_BUY) ? currentBid : currentAsk;
            double distanceFromLine = PriceDistanceInPips(currentPrice, lineStatuses[i].priceLevel);
            
            bool shouldReverse = false;
            
            if(posType == POSITION_TYPE_BUY)
            {
               if(currentBid < lineStatuses[i].priceLevel && distanceFromLine > ReverseDistancePips)
               {
                  shouldReverse = true;
                  Print("Ø¹ÙƒØ³ ÙÙˆØ±ÙŠ! ØµÙÙ‚Ø© Buy ØªØ¬Ø§ÙˆØ²Øª ", ReverseDistancePips, " Ù†Ù‚Ø·Ø© ØªØ­Øª Ø§Ù„Ø®Ø· | Ø§Ù„Ø®Ø·: ", lineStatuses[i].lineName);
               }
            }
            else
            {
               if(currentAsk > lineStatuses[i].priceLevel && distanceFromLine > ReverseDistancePips)
               {
                  shouldReverse = true;
                  Print("Ø¹ÙƒØ³ ÙÙˆØ±ÙŠ! ØµÙÙ‚Ø© Sell ØªØ¬Ø§ÙˆØ²Øª ", ReverseDistancePips, " Ù†Ù‚Ø·Ø© ÙÙˆÙ‚ Ø§Ù„Ø®Ø· | Ø§Ù„Ø®Ø·: ", lineStatuses[i].lineName);
               }
            }
            
            if(shouldReverse)
            {
               if(lineStatuses[i].isOpening)
               {
                  Print("âš ï¸ Ø¹Ù…Ù„ÙŠØ© ÙØªØ­ Ø¬Ø§Ø±ÙŠØ© Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø· - ØªÙ… ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ø¹ÙƒØ³ Ø§Ù„ÙÙˆØ±ÙŠ");
                  continue;
               }
               
               double lastLoss = PositionGetDouble(POSITION_PROFIT);
               if(lastLoss < 0)
               {
                  globalTotalLoss += MathAbs(lastLoss);
                  Print("ğŸ’° Ø®Ø³Ø§Ø±Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø¹ÙƒØ³ Ø§Ù„ÙÙˆØ±ÙŠ: ", MathAbs(lastLoss), " | Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø®Ø³Ø§Ø¦Ø± Ø§Ù„Ø¹Ø§Ù…: ", globalTotalLoss);
               }
               
               ulong oldTicket = lineStatuses[i].ticket;
               
               bool closed = ClosePositionForce(oldTicket, 10);
               
               if(!closed)
               {
                  Print("âŒâŒâŒ Ø¥ØºÙ„Ø§Ù‚ Ù…Ø³ØªØ­ÙŠÙ„! Ø³ÙŠØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¹ÙƒØ³");
                  continue;
               }
               
               Print("âœ… ØªØ£ÙƒÙŠØ¯: Ø§Ù„ØµÙÙ‚Ø© Ù…Ù‚ÙÙ„Ø© 100% - Ø³ÙŠØªÙ… ÙØªØ­ Ø§Ù„ØµÙÙ‚Ø© Ø§Ù„Ù…Ø¹Ø§ÙƒØ³Ø©");
               
               lineStatuses[i].isOpening = true;
               
               double currentEquity = AccountInfoDouble(ACCOUNT_EQUITY);
               lineStatuses[i].openEquity = currentEquity;
               lineStatuses[i].tradeCount++;
               lineStatuses[i].isFirstTrade = false;
               
               DeleteTargetLabel(lineStatuses[i].lineName);
               
               if(posType == POSITION_TYPE_BUY)
               {
                  Print("ğŸ”„ ÙØªØ­ ØµÙÙ‚Ø© Sell Ù…Ø¹Ø§ÙƒØ³Ø©...");
                  lineStatuses[i].ticket = OpenSell(lineStatuses[i].lineName);
                  lineStatuses[i].lastPosition = -1;
                  
                  double newPrice = AddOnePip(iHigh(_Symbol, _Period, 0), true);
                  lineStatuses[i].priceLevel = newPrice;
                  
                  Print("ğŸ”´ Ø­Ø°Ù Ø§Ù„Ø®Ø· Ø§Ù„Ù‚Ø¯ÙŠÙ… ÙˆØ¥Ù†Ø´Ø§Ø¡ Ø®Ø· Ø£Ø­Ù…Ø± Ø¬Ø¯ÙŠØ¯...");
                  
                  ObjectDelete(chartID, lineStatuses[i].lineName);
                  Sleep(100);
                  ChartRedraw(chartID);
                  
                  if(ObjectCreate(chartID, lineStatuses[i].lineName, OBJ_HLINE, 0, 0, newPrice))
                  {
                     ObjectSetInteger(chartID, lineStatuses[i].lineName, OBJPROP_COLOR, clrRed);
                     ObjectSetInteger(chartID, lineStatuses[i].lineName, OBJPROP_STYLE, STYLE_SOLID);
                     ObjectSetInteger(chartID, lineStatuses[i].lineName, OBJPROP_WIDTH, 3);
                     ObjectSetInteger(chartID, lineStatuses[i].lineName, OBJPROP_BACK, false);
                     ObjectSetInteger(chartID, lineStatuses[i].lineName, OBJPROP_SELECTABLE, false);
                     ObjectSetInteger(chartID, lineStatuses[i].lineName, OBJPROP_SELECTED, false);
                     
                     Print("âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø· Ø£Ø­Ù…Ø± Ø¬Ø¯ÙŠØ¯ Ø¹Ù†Ø¯: ", newPrice, " (High + 1 Ù†Ù‚Ø·Ø©)");
                  }
                  
                  Sleep(100);
                  ChartRedraw(chartID);
               }
               else
               {
                  Print("ğŸ”„ ÙØªØ­ ØµÙÙ‚Ø© Buy Ù…Ø¹Ø§ÙƒØ³Ø©...");
                  lineStatuses[i].ticket = OpenBuy(lineStatuses[i].lineName);
                  lineStatuses[i].lastPosition = 1;
                  
                  double newPrice = AddOnePip(iLow(_Symbol, _Period, 0), true);
                  lineStatuses[i].priceLevel = newPrice;
                  
                  Print("ğŸ”´ Ø­Ø°Ù Ø§Ù„Ø®Ø· Ø§Ù„Ù‚Ø¯ÙŠÙ… ÙˆØ¥Ù†Ø´Ø§Ø¡ Ø®Ø· Ø£Ø­Ù…Ø± Ø¬Ø¯ÙŠØ¯...");
                  
                  ObjectDelete(chartID, lineStatuses[i].lineName);
                  Sleep(100);
                  ChartRedraw(chartID);
                  
                  if(ObjectCreate(chartID, lineStatuses[i].lineName, OBJ_HLINE, 0, 0, newPrice))
                  {
                     ObjectSetInteger(chartID, lineStatuses[i].lineName, OBJPROP_COLOR, clrRed);
                     ObjectSetInteger(chartID, lineStatuses[i].lineName, OBJPROP_STYLE, STYLE_SOLID);
                     ObjectSetInteger(chartID, lineStatuses[i].lineName, OBJPROP_WIDTH, 3);
                     ObjectSetInteger(chartID, lineStatuses[i].lineName, OBJPROP_BACK, false);
                     ObjectSetInteger(chartID, lineStatuses[i].lineName, OBJPROP_SELECTABLE, false);
                     ObjectSetInteger(chartID, lineStatuses[i].lineName, OBJPROP_SELECTED, false);
                     
                     Print("âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø· Ø£Ø­Ù…Ø± Ø¬Ø¯ÙŠØ¯ Ø¹Ù†Ø¯: ", newPrice, " (Low + 1 Ù†Ù‚Ø·Ø©)");
                  }
                  
                  Sleep(100);
                  ChartRedraw(chartID);
               }
               
               RecalculateAllTargets();
               
               lineStatuses[i].isOpening = false;
            }
         }
      }
   }
}

void UpdateTargetLabel()
{
   long chartID = ChartID();
   string labelName = "CHL_TargetLabel";
   
   string labelText = StringFormat("Start: %.2f$ | Target: %.2f$", cycleStartEquity, cycleTotalTarget);
   
   if(ObjectFind(chartID, labelName) >= 0)
   {
      ObjectSetString(chartID, labelName, OBJPROP_TEXT, labelText);
   }
   else
   {
      ObjectCreate(chartID, labelName, OBJ_LABEL, 0, 0, 0);
      ObjectSetInteger(chartID, labelName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(chartID, labelName, OBJPROP_XDISTANCE, 10);
      ObjectSetInteger(chartID, labelName, OBJPROP_YDISTANCE, 20);
      ObjectSetInteger(chartID, labelName, OBJPROP_COLOR, clrOrange);
      ObjectSetInteger(chartID, labelName, OBJPROP_FONTSIZE, 12);
      ObjectSetString(chartID, labelName, OBJPROP_FONT, "Arial Bold");
      ObjectSetString(chartID, labelName, OBJPROP_TEXT, labelText);
      ObjectSetInteger(chartID, labelName, OBJPROP_SELECTABLE, false);
      ObjectSetInteger(chartID, labelName, OBJPROP_SELECTED, false);
   }
   
   ChartRedraw(chartID);
}

void UpdateLossLabel()
{
   long chartID = ChartID();
   string labelName = "CHL_LossLabel";
   
   string labelText = StringFormat("Total Loss: %.2f$", globalTotalLoss);
   color labelColor = (globalTotalLoss > 0) ? clrRed : clrLime;
   
   if(ObjectFind(chartID, labelName) >= 0)
   {
      ObjectSetString(chartID, labelName, OBJPROP_TEXT, labelText);
      ObjectSetInteger(chartID, labelName, OBJPROP_COLOR, labelColor);
   }
   else
   {
      ObjectCreate(chartID, labelName, OBJ_LABEL, 0, 0, 0);
      ObjectSetInteger(chartID, labelName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(chartID, labelName, OBJPROP_XDISTANCE, 10);
      ObjectSetInteger(chartID, labelName, OBJPROP_YDISTANCE, 40);
      ObjectSetInteger(chartID, labelName, OBJPROP_COLOR, labelColor);
      ObjectSetInteger(chartID, labelName, OBJPROP_FONTSIZE, 12);
      ObjectSetString(chartID, labelName, OBJPROP_FONT, "Arial Bold");
      ObjectSetString(chartID, labelName, OBJPROP_TEXT, labelText);
      ObjectSetInteger(chartID, labelName, OBJPROP_SELECTABLE, false);
      ObjectSetInteger(chartID, labelName, OBJPROP_SELECTED, false);
   }
   
   ChartRedraw(chartID);
}

void UpdateTotalProfitLabel()
{
   long chartID = ChartID();
   string labelName = "CHL_TotalProfitLabel";
   
   double totalProfitTarget = 0.0;
   
   if(globalTotalLoss > 0)
   {
      // â­ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø®Ø³Ø§Ø±Ø© Ø§Ù„ØµØ§ÙÙŠØ©
      double netLoss = globalTotalLoss;
      
      for(int i = 0; i < ArraySize(lineStatuses); i++)
      {
         if(lineStatuses[i].ticket > 0)
         {
            if(PositionSelectByTicket(lineStatuses[i].ticket))
            {
               double currentProfit = PositionGetDouble(POSITION_PROFIT);
               netLoss -= currentProfit;
            }
         }
      }
      
      if(netLoss < 0) netLoss = 0;
      
      totalProfitTarget = netLoss + (netLoss * RecoveryPercent / 100.0);
   }
   
   string labelText = StringFormat("Total Profit: %.2f$", totalProfitTarget);
   color labelColor = (totalProfitTarget > 0) ? clrLime : clrGray;
   
   if(ObjectFind(chartID, labelName) >= 0)
   {
      ObjectSetString(chartID, labelName, OBJPROP_TEXT, labelText);
      ObjectSetInteger(chartID, labelName, OBJPROP_COLOR, labelColor);
   }
   else
   {
      ObjectCreate(chartID, labelName, OBJ_LABEL, 0, 0, 0);
      ObjectSetInteger(chartID, labelName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(chartID, labelName, OBJPROP_XDISTANCE, 10);
      ObjectSetInteger(chartID, labelName, OBJPROP_YDISTANCE, 60);
      ObjectSetInteger(chartID, labelName, OBJPROP_COLOR, labelColor);
      ObjectSetInteger(chartID, labelName, OBJPROP_FONTSIZE, 12);
      ObjectSetString(chartID, labelName, OBJPROP_FONT, "Arial Bold");
      ObjectSetString(chartID, labelName, OBJPROP_TEXT, labelText);
      ObjectSetInteger(chartID, labelName, OBJPROP_SELECTABLE, false);
      ObjectSetInteger(chartID, labelName, OBJPROP_SELECTED, false);
   }
   
   ChartRedraw(chartID);
}

void UpdateTargetPerTradeLabel()
{
   long chartID = ChartID();
   string labelName = "CHL_TargetPerTradeLabel";
   
   double targetPerTrade = 0.0;
   
   if(globalTotalLoss > 0)
   {
      // â­ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø®Ø³Ø§Ø±Ø© Ø§Ù„ØµØ§ÙÙŠØ©
      double netLoss = globalTotalLoss;
      
      for(int i = 0; i < ArraySize(lineStatuses); i++)
      {
         if(lineStatuses[i].ticket > 0)
         {
            if(PositionSelectByTicket(lineStatuses[i].ticket))
            {
               double currentProfit = PositionGetDouble(POSITION_PROFIT);
               netLoss -= currentProfit;
            }
         }
      }
      
      if(netLoss < 0) netLoss = 0;
      
      double totalTarget = netLoss + (netLoss * RecoveryPercent / 100.0);
      
      int totalOpenPositions = CountOpenPositions();
      
      if(totalOpenPositions > 0)
      {
         targetPerTrade = totalTarget / totalOpenPositions;
      }
   }
   
   string labelText = StringFormat("Target Per Trade: %.2f$", targetPerTrade);
   color labelColor = (targetPerTrade > 0) ? clrLime : clrGray;
   
   if(ObjectFind(chartID, labelName) >= 0)
   {
      ObjectSetString(chartID, labelName, OBJPROP_TEXT, labelText);
      ObjectSetInteger(chartID, labelName, OBJPROP_COLOR, labelColor);
   }
   else
   {
      ObjectCreate(chartID, labelName, OBJ_LABEL, 0, 0, 0);
      ObjectSetInteger(chartID, labelName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(chartID, labelName, OBJPROP_XDISTANCE, 10);
      ObjectSetInteger(chartID, labelName, OBJPROP_YDISTANCE, 80);
      ObjectSetInteger(chartID, labelName, OBJPROP_COLOR, labelColor);
      ObjectSetInteger(chartID, labelName, OBJPROP_FONTSIZE, 12);
      ObjectSetString(chartID, labelName, OBJPROP_FONT, "Arial Bold");
      ObjectSetString(chartID, labelName, OBJPROP_TEXT, labelText);
      ObjectSetInteger(chartID, labelName, OBJPROP_SELECTABLE, false);
      ObjectSetInteger(chartID, labelName, OBJPROP_SELECTED, false);
   }
   
   ChartRedraw(chartID);
}

void UpdateOpenPositionsLabel()
{
   long chartID = ChartID();
   string labelName = "CHL_OpenPositionsLabel";
   
   int openPositions = CountOpenPositions();
   
   string labelText = StringFormat("Open Positions: %d", openPositions);
   color labelColor = clrWhite;
   
   if(ObjectFind(chartID, labelName) >= 0)
   {
      ObjectSetString(chartID, labelName, OBJPROP_TEXT, labelText);
   }
   else
   {
      ObjectCreate(chartID, labelName, OBJ_LABEL, 0, 0, 0);
      ObjectSetInteger(chartID, labelName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(chartID, labelName, OBJPROP_XDISTANCE, 10);
      ObjectSetInteger(chartID, labelName, OBJPROP_YDISTANCE, 100);
      ObjectSetInteger(chartID, labelName, OBJPROP_COLOR, labelColor);
      ObjectSetInteger(chartID, labelName, OBJPROP_FONTSIZE, 12);
      ObjectSetString(chartID, labelName, OBJPROP_FONT, "Arial Bold");
      ObjectSetString(chartID, labelName, OBJPROP_TEXT, labelText);
      ObjectSetInteger(chartID, labelName, OBJPROP_SELECTABLE, false);
      ObjectSetInteger(chartID, labelName, OBJPROP_SELECTED, false);
   }
   
   ChartRedraw(chartID);
}

void StartNewCycle()
{
   cycleStartEquity = AccountInfoDouble(ACCOUNT_EQUITY);
   cycleTotalTarget = cycleStartEquity * (1 + TotalProfitPercent / 100.0);
   
   globalTotalLoss = 0.0;
   
   Print(">>> START NEW CYCLE <<<");
   Print("New Equity: ", cycleStartEquity);
   Print("New Target: ", cycleTotalTarget);
   Print("Global Loss Reset: 0.0");
   
   UpdateTargetLabel();
   UpdateLossLabel();
   UpdateTotalProfitLabel();
   UpdateTargetPerTradeLabel();
   UpdateOpenPositionsLabel();
}

int CountExistingLines()
{
   long chartID = ChartID();
   int totalObjects = ObjectsTotal(chartID);
   int lineCount = 0;
   
   for(int i = 0; i < totalObjects; i++)
   {
      string objectName = ObjectName(chartID, i);
      if(StringFind(objectName, "GridLine_") >= 0)
      {
         lineCount++;
      }
   }
   
   return lineCount;
}

int CountOpenPositions()
{
   int count = 0;
   
   for(int i = 0; i < ArraySize(lineStatuses); i++)
   {
      if(lineStatuses[i].ticket > 0)
      {
         if(PositionSelectByTicket(lineStatuses[i].ticket))
         {
            count++;
         }
      }
   }
   
   return count;
}

void CleanupClosedPositions()
{
   long chartID = ChartID();
   
   for(int i = ArraySize(lineStatuses) - 1; i >= 0; i--)
   {
      if(lineStatuses[i].ticket > 0)
      {
         if(!PositionSelectByTicket(lineStatuses[i].ticket))
         {
            Print("ØµÙÙ‚Ø© Ù…Ù‚ÙÙ„Ø© ØªÙ… Ø§ÙƒØªØ´Ø§ÙÙ‡Ø§ (Ø¥ØºÙ„Ø§Ù‚ ÙŠØ¯ÙˆÙŠ) Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø·: ", lineStatuses[i].lineName, " | Ticket: ", lineStatuses[i].ticket);
            Print("Ø³ÙŠØªÙ… Ø­Ø°Ù Ø§Ù„Ø®Ø· (Ù…Ø¹Ø§Ù…Ù„Ø© ÙƒØªØ­Ù‚ÙŠÙ‚ Ù‡Ø¯Ù): ", lineStatuses[i].lineName);
            
            DeleteTargetLabel(lineStatuses[i].lineName);
            
            ObjectDelete(chartID, lineStatuses[i].lineName);
            
            RemoveLineFromStatus(i);
            
            ChartRedraw(chartID);
            
            int openPositions = CountOpenPositions();
            Print("Ø¹Ø¯Ø¯ Ø§Ù„ØµÙÙ‚Ø§Øª Ø§Ù„Ù…ÙØªÙˆØ­Ø© Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ©: ", openPositions);
            
            if(openPositions == 0)
            {
               Print("ÙƒÙ„ Ø§Ù„ØµÙÙ‚Ø§Øª Ø£ØºÙ„Ù‚Øª!");
               
               if(RunOneCycle)
               {
                  Print(">>> ÙˆØ¶Ø¹ Ø§Ù„Ø¯ÙˆØ±Ø© Ø§Ù„ÙˆØ§Ø­Ø¯Ø© Ù…ÙØ¹Ù‘Ù„ - Ø§Ù„Ø¥ÙƒØ³Ø¨Ø±Øª Ø³ÙŠØªÙˆÙ‚Ù Ø§Ù„Ø¢Ù† <<<");
                  cycleCompleted = true;
                  return;
               }
               
               Print("Ø³ÙŠØªÙ… Ø¨Ø¯Ø§ÙŠØ© Ø¯ÙˆØ±Ø© Ø¬Ø¯ÙŠØ¯Ø©...");
               
               StartNewCycle();
            }
         }
      }
   }
}

void CheckTotalProfitTarget()
{
   double currentEquity = AccountInfoDouble(ACCOUNT_EQUITY);
   
   if(currentEquity >= cycleTotalTarget)
   {
      Print("ØªÙ… ØªØ­Ù‚ÙŠÙ‚ Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ!");
      Print("Ø§Ù„Ø¥ÙŠÙƒÙˆÙŠØªÙŠ Ø§Ù„Ø­Ø§Ù„ÙŠ: ", currentEquity, " | Ø§Ù„Ù‡Ø¯Ù ÙƒØ§Ù†: ", cycleTotalTarget);
      Print("Ø§Ù„Ø±Ø¨Ø­ Ø§Ù„Ù…Ø­Ù‚Ù‚: ", (currentEquity - cycleStartEquity));
      
      CloseAllOpenPositionsAndDeleteLines();
      
      if(RunOneCycle)
      {
         Print(">>> ÙˆØ¶Ø¹ Ø§Ù„Ø¯ÙˆØ±Ø© Ø§Ù„ÙˆØ§Ø­Ø¯Ø© Ù…ÙØ¹Ù‘Ù„ - Ø§Ù„Ø¥ÙƒØ³Ø¨Ø±Øª Ø³ÙŠØªÙˆÙ‚Ù Ø§Ù„Ø¢Ù† <<<");
         cycleCompleted = true;
         return;
      }
      
      StartNewCycle();
   }
}

void CloseAllOpenPositionsAndDeleteLines()
{
   long chartID = ChartID();
   Print("Ø¬Ø§Ø±ÙŠ Ø¥Ù‚ÙØ§Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØµÙÙ‚Ø§Øª Ø§Ù„Ù…ÙØªÙˆØ­Ø© ÙˆØ­Ø°Ù Ø®Ø·ÙˆØ·Ù‡Ø§...");
   
   for(int i = ArraySize(lineStatuses) - 1; i >= 0; i--)
   {
      if(lineStatuses[i].ticket > 0)
      {
         Print("Ø¥Ù‚ÙØ§Ù„ Ø§Ù„ØµÙÙ‚Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø·: ", lineStatuses[i].lineName, " | Ticket: ", lineStatuses[i].ticket);
         
         ClosePositionForce(lineStatuses[i].ticket, 10);
         
         DeleteTargetLabel(lineStatuses[i].lineName);
         
         ObjectDelete(chartID, lineStatuses[i].lineName);
         Print("ØªÙ… Ø­Ø°Ù Ø§Ù„Ø®Ø·: ", lineStatuses[i].lineName);
         
         RemoveLineFromStatus(i);
      }
   }
   
   ChartRedraw(chartID);
   Print("ØªÙ… Ø¥Ù‚ÙØ§Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØµÙÙ‚Ø§Øª ÙˆØ­Ø°Ù Ø®Ø·ÙˆØ·Ù‡Ø§ | Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ©: ", ArraySize(lineStatuses));
}

double CalculateLotSize()
{
   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   
   double riskAmount = (balance / 1000.0) * RiskPerThousand;
   
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   
   double pointValue = (tickValue / tickSize) * point;
   
   double lotSize = riskAmount / (pointValue * 10);
   
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   
   lotSize = MathFloor(lotSize / lotStep) * lotStep;
   
   if(lotSize < minLot) lotSize = minLot;
   if(lotSize > maxLot) lotSize = maxLot;
   
   return lotSize;
}

void CheckProfitTargets()
{
   long chartID = ChartID();
   
   for(int i = ArraySize(lineStatuses) - 1; i >= 0; i--)
   {
      if(lineStatuses[i].ticket > 0)
      {
         if(PositionSelectByTicket(lineStatuses[i].ticket))
         {
            double currentProfit = PositionGetDouble(POSITION_PROFIT);
            
            if(currentProfit >= lineStatuses[i].targetProfit)
            {
               Print("ğŸ‰ ØªÙ… ØªØ­Ù‚ÙŠÙ‚ Ø§Ù„Ù‡Ø¯Ù Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø·: ", lineStatuses[i].lineName);
               Print("Ø§Ù„Ø±Ø¨Ø­: ", currentProfit, " | Ø§Ù„Ù‡Ø¯Ù ÙƒØ§Ù†: ", lineStatuses[i].targetProfit);
               
               if(!lineStatuses[i].isFirstTrade && globalTotalLoss > 0)
               {
                  globalTotalLoss -= currentProfit;
                  if(globalTotalLoss < 0) globalTotalLoss = 0;
                  
                  Print("ğŸ’° Ø®ØµÙ… Ø§Ù„Ø±Ø¨Ø­ Ù…Ù† Ø§Ù„Ø®Ø³Ø§Ø¦Ø± | Ø§Ù„Ø®Ø³Ø§Ø¦Ø± Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ©: ", globalTotalLoss);
               }
               
               Print("Ø³ÙŠØªÙ… Ø­Ø°Ù Ø§Ù„Ø®Ø· Ù†Ù‡Ø§Ø¦ÙŠØ§Ù‹: ", lineStatuses[i].lineName);
               
               ClosePositionForce(lineStatuses[i].ticket, 10);
               
               DeleteTargetLabel(lineStatuses[i].lineName);
               
               if(ObjectFind(chartID, lineStatuses[i].lineName) >= 0)
               {
                  ObjectDelete(chartID, lineStatuses[i].lineName);
                  Print("ØªÙ… Ø­Ø°Ù Ø§Ù„Ø®Ø· Ù…Ù† Ø§Ù„Ø´Ø§Ø±Øª: ", lineStatuses[i].lineName);
               }
               
               RemoveLineFromStatus(i);
               
               ChartRedraw(chartID);
               
               RecalculateAllTargets();
               
               int openPositions = CountOpenPositions();
               Print("Ø¹Ø¯Ø¯ Ø§Ù„ØµÙÙ‚Ø§Øª Ø§Ù„Ù…ÙØªÙˆØ­Ø© Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ©: ", openPositions);
               
               if(openPositions == 0)
               {
                  Print("ÙƒÙ„ Ø§Ù„ØµÙÙ‚Ø§Øª Ø­Ù‚Ù‚Øª Ø£Ù‡Ø¯Ø§ÙÙ‡Ø§!");
                  
                  if(RunOneCycle)
                  {
                     Print(">>> ÙˆØ¶Ø¹ Ø§Ù„Ø¯ÙˆØ±Ø© Ø§Ù„ÙˆØ§Ø­Ø¯Ø© Ù…ÙØ¹Ù‘Ù„ - Ø§Ù„Ø¥ÙƒØ³Ø¨Ø±Øª Ø³ÙŠØªÙˆÙ‚Ù Ø§Ù„Ø¢Ù† <<<");
                     cycleCompleted = true;
                     return;
                  }
                  
                  Print("Ø³ÙŠØªÙ… Ø¨Ø¯Ø§ÙŠØ© Ø¯ÙˆØ±Ø© Ø¬Ø¯ÙŠØ¯Ø©...");
                  
                  StartNewCycle();
               }
            }
         }
         else
         {
            Print("Ø§Ù„ØµÙÙ‚Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©! Ticket: ", lineStatuses[i].ticket, " | Ø§Ù„Ø®Ø·: ", lineStatuses[i].lineName);
            
            DeleteTargetLabel(lineStatuses[i].lineName);
            
            ObjectDelete(chartID, lineStatuses[i].lineName);
            RemoveLineFromStatus(i);
            ChartRedraw(chartID);
            
            RecalculateAllTargets();
            
            int openPositions = CountOpenPositions();
            Print("Ø¹Ø¯Ø¯ Ø§Ù„ØµÙÙ‚Ø§Øª Ø§Ù„Ù…ÙØªÙˆØ­Ø© Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ©: ", openPositions);
            
            if(openPositions == 0)
            {
               Print("ÙƒÙ„ Ø§Ù„ØµÙÙ‚Ø§Øª Ø£ØºÙ„Ù‚Øª!");
               
               if(RunOneCycle)
               {
                  Print(">>> ÙˆØ¶Ø¹ Ø§Ù„Ø¯ÙˆØ±Ø© Ø§Ù„ÙˆØ§Ø­Ø¯Ø© Ù…ÙØ¹Ù‘Ù„ - Ø§Ù„Ø¥ÙƒØ³Ø¨Ø±Øª Ø³ÙŠØªÙˆÙ‚Ù Ø§Ù„Ø¢Ù† <<<");
                  cycleCompleted = true;
                  return;
               }
               
               Print("Ø³ÙŠØªÙ… Ø¨Ø¯Ø§ÙŠØ© Ø¯ÙˆØ±Ø© Ø¬Ø¯ÙŠØ¯Ø©...");
               
               StartNewCycle();
            }
         }
      }
   }
}

void RemoveLineFromStatus(int index)
{
   int size = ArraySize(lineStatuses);
   
   if(index < 0 || index >= size)
      return;
   
   Print("Ø­Ø°Ù Ø§Ù„Ø®Ø· Ù…Ù† Ø§Ù„ØªØªØ¨Ø¹: ", lineStatuses[index].lineName);
   
   for(int i = index; i < size - 1; i++)
   {
      lineStatuses[i].lineName = lineStatuses[i + 1].lineName;
      lineStatuses[i].priceLevel = lineStatuses[i + 1].priceLevel;
      lineStatuses[i].lastPosition = lineStatuses[i + 1].lastPosition;
      lineStatuses[i].ticket = lineStatuses[i + 1].ticket;
      lineStatuses[i].openEquity = lineStatuses[i + 1].openEquity;
      lineStatuses[i].targetProfit = lineStatuses[i + 1].targetProfit;
      lineStatuses[i].tradeCount = lineStatuses[i + 1].tradeCount;
      lineStatuses[i].hasOpenedTrade = lineStatuses[i + 1].hasOpenedTrade;
      lineStatuses[i].isOpening = lineStatuses[i + 1].isOpening;
      lineStatuses[i].isFirstTrade = lineStatuses[i + 1].isFirstTrade;
   }
   
   ArrayResize(lineStatuses, size - 1);
   
   Print("Ø¹Ø¯Ø¯ Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ©: ", ArraySize(lineStatuses));
}

bool IsLineLevelExists(double priceLevel, double tolerance = 0.0001)
{
   long chartID = ChartID();
   int totalObjects = ObjectsTotal(chartID);
   
   for(int i = 0; i < totalObjects; i++)
   {
      string objectName = ObjectName(chartID, i);
      
      if(StringFind(objectName, "GridLine_") >= 0)
      {
         double existingPrice = ObjectGetDouble(chartID, objectName, OBJPROP_PRICE);
         
         if(MathAbs(existingPrice - priceLevel) <= tolerance)
         {
            return true;
         }
      }
   }
   
   return false;
}

//+------------------------------------------------------------------+
//| â­â­â­ Ø±Ø³Ù… Ø§Ù„Ø®Ø·ÙˆØ· - Ù†Ø¸Ø§Ù… Grid Ø§Ù„Ø¬Ø¯ÙŠØ¯ (Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø·) â­â­â­          |
//+------------------------------------------------------------------+
void DrawLines()
{
   long chartID = ChartID();
   double currentPrice = iClose(_Symbol, _Period, 0);
   double gridStepPrice = PipsToPrice(GridStepPips);
   double halfStepPrice = PipsToPrice(GridStepPips / 2.0);
   
   Print("==============================================");
   Print("ğŸ¨ Ø¨Ø¯Ø§ÙŠØ© Ø±Ø³Ù… Ø®Ø·ÙˆØ· Grid (Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø·)");
   Print("==============================================");
   Print("Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ: ", currentPrice);
   Print("Ø§Ù„Ù…Ø³Ø§ÙØ© Ø§Ù„ÙƒØ§Ù…Ù„Ø©: ", GridStepPips, " Ù†Ù‚Ø·Ø©");
   Print("Ù†ØµÙ Ø§Ù„Ù…Ø³Ø§ÙØ© (Ø§Ù„Ø®Ø· Ø§Ù„Ø£ÙˆÙ„): ", (GridStepPips / 2.0), " Ù†Ù‚Ø·Ø©");
   Print("Ø¹Ø¯Ø¯ Ø§Ù„Ø®Ø·ÙˆØ· ÙÙˆÙ‚/ØªØ­Øª: ", NumberOfLines);
   Print("==============================================");
   
   int linesDrawn = 0;
   
   // â­ Ø±Ø³Ù… Ø§Ù„Ø®Ø·ÙˆØ· ÙÙˆÙ‚ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ
   // Ø§Ù„Ø®Ø· Ø§Ù„Ø£ÙˆÙ„ = Ù†ØµÙ Ø§Ù„Ù…Ø³Ø§ÙØ©
   // Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„ØªØ§Ù„ÙŠØ© = Ù†ØµÙ + (Ù…Ø¶Ø§Ø¹ÙØ§Øª Ø§Ù„Ù…Ø³Ø§ÙØ© Ø§Ù„ÙƒØ§Ù…Ù„Ø©)
   for(int i = 1; i <= NumberOfLines; i++)
   {
      double linePrice;
      
      if(i == 1)
      {
         // Ø§Ù„Ø®Ø· Ø§Ù„Ø£ÙˆÙ„: Ù†ØµÙ Ø§Ù„Ù…Ø³Ø§ÙØ© ÙÙ‚Ø·
         linePrice = currentPrice + halfStepPrice;
      }
      else
      {
         // Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„ØªØ§Ù„ÙŠØ©: Ù†ØµÙ + (i-1) * Ø§Ù„Ù…Ø³Ø§ÙØ© Ø§Ù„ÙƒØ§Ù…Ù„Ø©
         linePrice = currentPrice + halfStepPrice + ((i - 1) * gridStepPrice);
      }
      
      string lineName = "GridLine_UP_" + IntegerToString(i) + "_" + DoubleToString(linePrice, _Digits);
      
      if(!IsLineLevelExists(linePrice))
      {
         if(ObjectCreate(chartID, lineName, OBJ_HLINE, 0, 0, linePrice))
         {
            ObjectSetInteger(chartID, lineName, OBJPROP_COLOR, clrOrange);
            ObjectSetInteger(chartID, lineName, OBJPROP_STYLE, STYLE_DOT);
            ObjectSetInteger(chartID, lineName, OBJPROP_WIDTH, 1);
            ObjectSetInteger(chartID, lineName, OBJPROP_BACK, true);
            ObjectSetInteger(chartID, lineName, OBJPROP_SELECTABLE, false);
            ObjectSetInteger(chartID, lineName, OBJPROP_SELECTED, false);
            
            linesDrawn++;
            double distancePips = PriceDistanceInPips(currentPrice, linePrice);
            Print("âœ… Ø®Ø· ÙÙˆÙ‚ #", i, ": ", lineName);
            Print("   Ø§Ù„Ø³Ø¹Ø±: ", linePrice, " | Ø§Ù„Ù…Ø³Ø§ÙØ©: ", distancePips, " Ù†Ù‚Ø·Ø©");
         }
      }
   }
   
   // â­ Ø±Ø³Ù… Ø§Ù„Ø®Ø·ÙˆØ· ØªØ­Øª Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ
   // Ù†ÙØ³ Ø§Ù„Ù…Ù†Ø·Ù‚ Ù„ÙƒÙ† Ø¨Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù…Ø¹Ø§ÙƒØ³
   for(int i = 1; i <= NumberOfLines; i++)
   {
      double linePrice;
      
      if(i == 1)
      {
         // Ø§Ù„Ø®Ø· Ø§Ù„Ø£ÙˆÙ„: Ù†ØµÙ Ø§Ù„Ù…Ø³Ø§ÙØ© ÙÙ‚Ø·
         linePrice = currentPrice - halfStepPrice;
      }
      else
      {
         // Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„ØªØ§Ù„ÙŠØ©: Ù†ØµÙ + (i-1) * Ø§Ù„Ù…Ø³Ø§ÙØ© Ø§Ù„ÙƒØ§Ù…Ù„Ø©
         linePrice = currentPrice - halfStepPrice - ((i - 1) * gridStepPrice);
      }
      
      string lineName = "GridLine_DOWN_" + IntegerToString(i) + "_" + DoubleToString(linePrice, _Digits);
      
      if(!IsLineLevelExists(linePrice))
      {
         if(ObjectCreate(chartID, lineName, OBJ_HLINE, 0, 0, linePrice))
         {
            ObjectSetInteger(chartID, lineName, OBJPROP_COLOR, clrOrange);
            ObjectSetInteger(chartID, lineName, OBJPROP_STYLE, STYLE_DOT);
            ObjectSetInteger(chartID, lineName, OBJPROP_WIDTH, 1);
            ObjectSetInteger(chartID, lineName, OBJPROP_BACK, true);
            ObjectSetInteger(chartID, lineName, OBJPROP_SELECTABLE, false);
            ObjectSetInteger(chartID, lineName, OBJPROP_SELECTED, false);
            
            linesDrawn++;
            double distancePips = PriceDistanceInPips(currentPrice, linePrice);
            Print("âœ… Ø®Ø· ØªØ­Øª #", i, ": ", lineName);
            Print("   Ø§Ù„Ø³Ø¹Ø±: ", linePrice, " | Ø§Ù„Ù…Ø³Ø§ÙØ©: ", distancePips, " Ù†Ù‚Ø·Ø©");
         }
      }
   }
   
   Print("==============================================");
   Print("âœ… Ø§Ù†ØªÙ‡Ù‰ Ø±Ø³Ù… Ø®Ø·ÙˆØ· Grid");
   Print("Ø¹Ø¯Ø¯ Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„Ù…Ø±Ø³ÙˆÙ…Ø©: ", linesDrawn);
   Print("==============================================");
   
   ChartRedraw(chartID);
}

void AddLineToStatus(string lineName, double priceLevel)
{
   int currentSize = ArraySize(lineStatuses);
   ArrayResize(lineStatuses, currentSize + 1);
   
   double currentClose = iClose(_Symbol, _Period, 1);
   
   lineStatuses[currentSize].lineName = lineName;
   lineStatuses[currentSize].priceLevel = priceLevel;
   
   if(currentClose > priceLevel)
      lineStatuses[currentSize].lastPosition = 1;
   else if(currentClose < priceLevel)
      lineStatuses[currentSize].lastPosition = -1;
   else
      lineStatuses[currentSize].lastPosition = 0;
      
   lineStatuses[currentSize].ticket = 0;
   lineStatuses[currentSize].openEquity = 0;
   lineStatuses[currentSize].targetProfit = 0;
   lineStatuses[currentSize].tradeCount = 0;
   lineStatuses[currentSize].hasOpenedTrade = false;
   lineStatuses[currentSize].isOpening = false;
   lineStatuses[currentSize].isFirstTrade = false;
}

void InitializeLineStatuses()
{
   long chartID = ChartID();
   int totalObjects = ObjectsTotal(chartID);
   int lineCount = 0;
   
   for(int i = 0; i < totalObjects; i++)
   {
      string objectName = ObjectName(chartID, i);
      if(StringFind(objectName, "GridLine_") >= 0)
      {
         lineCount++;
      }
   }
   
   ArrayResize(lineStatuses, lineCount);
   
   int index = 0;
   double currentClose = iClose(_Symbol, _Period, 1);
   
   for(int i = 0; i < totalObjects; i++)
   {
      string objectName = ObjectName(chartID, i);
      
      if(StringFind(objectName, "GridLine_") >= 0)
      {
         double linePrice = ObjectGetDouble(chartID, objectName, OBJPROP_PRICE);
         color lineColor = (color)ObjectGetInteger(chartID, objectName, OBJPROP_COLOR);
         
         lineStatuses[index].lineName = objectName;
         lineStatuses[index].priceLevel = linePrice;
         
         if(currentClose > linePrice)
            lineStatuses[index].lastPosition = 1;
         else if(currentClose < linePrice)
            lineStatuses[index].lastPosition = -1;
         else
            lineStatuses[index].lastPosition = 0;
         
         ulong foundTicket = 0;
         int totalPositions = PositionsTotal();
         
         for(int p = 0; p < totalPositions; p++)
         {
            ulong ticket = PositionGetTicket(p);
            if(ticket > 0)
            {
               string posComment = PositionGetString(POSITION_COMMENT);
               
               if(StringFind(posComment, objectName) >= 0)
               {
                  foundTicket = ticket;
                  Print("ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ØµÙÙ‚Ø© Ù…ÙØªÙˆØ­Ø© Ù„Ù„Ø®Ø·: ", objectName, " | Ticket: ", foundTicket);
                  break;
               }
            }
         }
         
         if(foundTicket > 0)
         {
            lineStatuses[index].ticket = foundTicket;
            lineStatuses[index].hasOpenedTrade = true;
            lineStatuses[index].isFirstTrade = false;
            
            if(PositionSelectByTicket(foundTicket))
            {
               ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
               lineStatuses[index].lastPosition = (posType == POSITION_TYPE_BUY) ? 1 : -1;
            }
            
            lineStatuses[index].openEquity = 0;
            lineStatuses[index].targetProfit = 0;
            lineStatuses[index].tradeCount = 1;
            
            Print("Ø§Ù„Ø®Ø· ", objectName, " Ù…Ø±Ø¨ÙˆØ· Ù…Ø¹ Ø§Ù„ØµÙÙ‚Ø© - Ø¬Ø§Ù‡Ø² Ù„Ù„Ø¹Ù…Ù„!");
         }
         else
         {
            lineStatuses[index].ticket = 0;
            lineStatuses[index].openEquity = 0;
            lineStatuses[index].targetProfit = 0;
            lineStatuses[index].tradeCount = 0;
            lineStatuses[index].hasOpenedTrade = false;
            lineStatuses[index].isFirstTrade = false;
         }
         
         lineStatuses[index].isOpening = false;
         
         index++;
      }
   }
   
   Print("ØªÙ… ØªÙ‡ÙŠØ¦Ø© ", lineCount, " Ø®Ø·");
}

void CheckLinesCrossing()
{
   long chartID = ChartID();
   double currentClose = iClose(_Symbol, _Period, 1);
   
   for(int i = 0; i < ArraySize(lineStatuses); i++)
   {
      int newPosition;
      
      if(currentClose > lineStatuses[i].priceLevel)
         newPosition = 1;
      else if(currentClose < lineStatuses[i].priceLevel)
         newPosition = -1;
      else
         continue;
      
      if(newPosition != lineStatuses[i].lastPosition)
      {
         Print("Ø§Ø®ØªØ±Ø§Ù‚ Ù„Ù„Ø®Ø·: ", lineStatuses[i].lineName, " | Ø§Ù„Ø³Ø¹Ø±: ", lineStatuses[i].priceLevel);
         
         if(!lineStatuses[i].hasOpenedTrade)
         {
            if(lineStatuses[i].ticket > 0)
            {
               Print("âš ï¸ Ø§Ù„Ø®Ø· ", lineStatuses[i].lineName, " Ø¹Ù„ÙŠÙ‡ ØµÙÙ‚Ø© Ù…ÙØªÙˆØ­Ø© Ø¨Ø§Ù„ÙØ¹Ù„");
               lineStatuses[i].hasOpenedTrade = true;
               continue;
            }
            
            bool hasExistingPosition = false;
            int totalPos = PositionsTotal();
            for(int p = 0; p < totalPos; p++)
            {
               ulong ticket = PositionGetTicket(p);
               if(ticket > 0)
               {
                  string posComment = PositionGetString(POSITION_COMMENT);
                  if(StringFind(posComment, lineStatuses[i].lineName) >= 0)
                  {
                     hasExistingPosition = true;
                     lineStatuses[i].ticket = ticket;
                     lineStatuses[i].hasOpenedTrade = true;
                     break;
                  }
               }
            }
            
            if(hasExistingPosition)
            {
               continue;
            }
            
            if(lineStatuses[i].isOpening)
            {
               Print("âš ï¸ Ø¹Ù…Ù„ÙŠØ© ÙØªØ­ Ø¬Ø§Ø±ÙŠØ© Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø· ", lineStatuses[i].lineName);
               continue;
            }
            
            double distanceFromLine = PriceDistanceInPips(currentClose, lineStatuses[i].priceLevel);
            
            if(distanceFromLine > MaxDistanceForNewEntry)
            {
               Print("Ø§Ù„Ù…Ø³Ø§ÙØ© ÙƒØ¨ÙŠØ±Ø© - Ø³ÙŠØªÙ… Ø­Ø°Ù Ø§Ù„Ø®Ø· Ø§Ù„Ø¨Ø±ØªÙ‚Ø§Ù„ÙŠ: ", lineStatuses[i].lineName);
               
               ObjectDelete(chartID, lineStatuses[i].lineName);
               RemoveLineFromStatus(i);
               ChartRedraw(chartID);
               
               i--;
               continue;
            }
         }
         
         lineStatuses[i].isOpening = true;
         
         double lastLoss = 0;
         if(lineStatuses[i].ticket > 0)
         {
            if(PositionSelectByTicket(lineStatuses[i].ticket))
            {
               lastLoss = PositionGetDouble(POSITION_PROFIT);
               
               if(lastLoss < 0)
               {
                  globalTotalLoss += MathAbs(lastLoss);
                  Print("ğŸ’° Ø®Ø³Ø§Ø±Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø¹ÙƒØ³: ", MathAbs(lastLoss), " | Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø®Ø³Ø§Ø¦Ø± Ø§Ù„Ø¹Ø§Ù…: ", globalTotalLoss);
               }
            }
            
            bool closed = ClosePositionForce(lineStatuses[i].ticket, 10);
            
            if(!closed)
            {
               Print("âŒ ÙØ´Ù„ Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ - Ù„Ù† ÙŠØªÙ… ÙØªØ­ ØµÙÙ‚Ø© Ø¬Ø¯ÙŠØ¯Ø©");
               lineStatuses[i].isOpening = false;
               continue;
            }
            
            DeleteTargetLabel(lineStatuses[i].lineName);
            
            lineStatuses[i].ticket = 0;
         }
         
         double currentEquity = AccountInfoDouble(ACCOUNT_EQUITY);
         lineStatuses[i].openEquity = currentEquity;
         lineStatuses[i].tradeCount++;
         
         if(lineStatuses[i].tradeCount == 1 && globalTotalLoss == 0)
         {
            lineStatuses[i].isFirstTrade = true;
            lineStatuses[i].targetProfit = currentEquity * (ProfitPercent / 100.0);
            Print("ğŸ¯ ØµÙÙ‚Ø© Ø£ÙˆÙ„Ù‰ | Ø§Ù„Ù‡Ø¯Ù: ", lineStatuses[i].targetProfit);
         }
         else
         {
            lineStatuses[i].isFirstTrade = false;
            lineStatuses[i].targetProfit = 0;
            Print("ğŸ¯ ØµÙÙ‚Ø© ÙÙŠ Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙˆØ²ÙŠØ¹");
         }
         
         Print("Ø¹Ø¯Ø¯ Ø§Ù„ØµÙÙ‚Ø§Øª Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø· ", lineStatuses[i].lineName, " = ", lineStatuses[i].tradeCount);
         
         if(newPosition == 1)
         {
            lineStatuses[i].ticket = OpenBuy(lineStatuses[i].lineName);
            
            if(lineStatuses[i].ticket > 0)
            {
               lineStatuses[i].hasOpenedTrade = true;
               
               double newPrice = AddOnePip(iLow(_Symbol, _Period, 1), true);
               lineStatuses[i].priceLevel = newPrice;
               
               ObjectSetDouble(chartID, lineStatuses[i].lineName, OBJPROP_PRICE, newPrice);
               Sleep(50);
               
               ObjectSetInteger(chartID, lineStatuses[i].lineName, OBJPROP_COLOR, clrRed);
               Sleep(50);
               
               ObjectSetInteger(chartID, lineStatuses[i].lineName, OBJPROP_STYLE, STYLE_SOLID);
               Sleep(50);
               
               ObjectSetInteger(chartID, lineStatuses[i].lineName, OBJPROP_WIDTH, 2);
               Sleep(50);
               
               ChartRedraw(chartID);
               
               Print("âœ… ØªÙ… ØªØºÙŠÙŠØ± Ù„ÙˆÙ† Ø§Ù„Ø®Ø· Ø¥Ù„Ù‰ Red");
               
               if(!lineStatuses[i].isFirstTrade)
               {
                  RecalculateAllTargets();
               }
               else
               {
                  CreateOrUpdateTargetLabel(lineStatuses[i].lineName, newPrice, lineStatuses[i].targetProfit);
               }
            }
         }
         else if(newPosition == -1)
         {
            lineStatuses[i].ticket = OpenSell(lineStatuses[i].lineName);
            
            if(lineStatuses[i].ticket > 0)
            {
               lineStatuses[i].hasOpenedTrade = true;
               
               double newPrice = AddOnePip(iHigh(_Symbol, _Period, 1), true);
               lineStatuses[i].priceLevel = newPrice;
               
               ObjectSetDouble(chartID, lineStatuses[i].lineName, OBJPROP_PRICE, newPrice);
               Sleep(50);
               
               ObjectSetInteger(chartID, lineStatuses[i].lineName, OBJPROP_COLOR, clrRed);
               Sleep(50);
               
               ObjectSetInteger(chartID, lineStatuses[i].lineName, OBJPROP_STYLE, STYLE_SOLID);
               Sleep(50);
               
               ObjectSetInteger(chartID, lineStatuses[i].lineName, OBJPROP_WIDTH, 2);
               Sleep(50);
               
               ChartRedraw(chartID);
               
               Print("âœ… ØªÙ… ØªØºÙŠÙŠØ± Ù„ÙˆÙ† Ø§Ù„Ø®Ø· Ø¥Ù„Ù‰ Red");
               
               if(!lineStatuses[i].isFirstTrade)
               {
                  RecalculateAllTargets();
               }
               else
               {
                  CreateOrUpdateTargetLabel(lineStatuses[i].lineName, newPrice, lineStatuses[i].targetProfit);
               }
            }
         }
         
         lineStatuses[i].isOpening = false;
         
         lineStatuses[i].lastPosition = newPosition;
      }
   }
}

ulong OpenBuy(string lineName)
{
   double lotSize = CalculateLotSize();
   
   MqlTradeRequest request;
   MqlTradeResult result;
   ZeroMemory(request);
   ZeroMemory(result);
   
   request.action = TRADE_ACTION_DEAL;
   request.symbol = _Symbol;
   request.volume = lotSize;
   request.type = ORDER_TYPE_BUY;
   request.price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   request.deviation = Slippage;
   request.magic = 123456;
   request.comment = CommentPrefix + lineName;
   
   if(OrderSend(request, result))
   {
      if(result.retcode == TRADE_RETCODE_DONE)
      {
         Print("âœ… ØµÙÙ‚Ø© Ø´Ø±Ø§Ø¡ Ù…ÙØªÙˆØ­Ø©: ", lineName, " | Ticket: ", result.order);
         return result.order;
      }
   }
   
   Print("âŒ ÙØ´Ù„ ÙØªØ­ ØµÙÙ‚Ø© Ø´Ø±Ø§Ø¡: ", lineName);
   return 0;
}

ulong OpenSell(string lineName)
{
   double lotSize = CalculateLotSize();
   
   MqlTradeRequest request;
   MqlTradeResult result;
   ZeroMemory(request);
   ZeroMemory(result);
   
   request.action = TRADE_ACTION_DEAL;
   request.symbol = _Symbol;
   request.volume = lotSize;
   request.type = ORDER_TYPE_SELL;
   request.price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   request.deviation = Slippage;
   request.magic = 123456;
   request.comment = CommentPrefix + lineName;
   
   if(OrderSend(request, result))
   {
      if(result.retcode == TRADE_RETCODE_DONE)
      {
         Print("âœ… ØµÙÙ‚Ø© Ø¨ÙŠØ¹ Ù…ÙØªÙˆØ­Ø©: ", lineName, " | Ticket: ", result.order);
         return result.order;
      }
   }
   
   Print("âŒ ÙØ´Ù„ ÙØªØ­ ØµÙÙ‚Ø© Ø¨ÙŠØ¹: ", lineName);
   return 0;
}

void DeleteAllLines()
{
   long chartID = ChartID();
   int totalObjects = ObjectsTotal(chartID);
   
   for(int i = totalObjects - 1; i >= 0; i--)
   {
      string objectName = ObjectName(chartID, i);
      
      if(StringFind(objectName, "GridLine_") >= 0)
      {
         ObjectDelete(chartID, objectName);
      }
      
      if(StringFind(objectName, "Target_") >= 0)
      {
         ObjectDelete(chartID, objectName);
      }
   }
}

void DeleteOrangeLinesOnly()
{
   long chartID = ChartID();
   int totalObjects = ObjectsTotal(chartID);
   int deletedCount = 0;
   
   for(int i = totalObjects - 1; i >= 0; i--)
   {
      string objectName = ObjectName(chartID, i);
      
      if(StringFind(objectName, "GridLine_") >= 0)
      {
         color lineColor = (color)ObjectGetInteger(chartID, objectName, OBJPROP_COLOR);
         
         if(lineColor == clrOrange)
         {
            ObjectDelete(chartID, objectName);
            deletedCount++;
         }
      }
   }
   
   Print("ØªÙ… Ø­Ø°Ù ", deletedCount, " Ø®Ø· Ø¨Ø±ØªÙ‚Ø§Ù„ÙŠ");
}  